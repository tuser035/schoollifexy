# MindTalk 상담 조회 - 키워드 사용횟수 히트맵 구현하기

## 📚 학습 목표
이 문서를 따라하면 다음을 배울 수 있어요:
- **히트맵(Heatmap)**이 무엇인지 이해하기
- React 컴포넌트를 새로 만드는 방법
- 데이터를 계산하고 시각화하는 방법
- 컴포넌트 간에 데이터를 전달하는 방법 (Props)
- 클릭 이벤트 처리하기

---

## 🎯 히트맵이란?

**히트맵(Heatmap)**은 데이터의 크기를 **색상의 진하기**로 표현하는 시각화 방법이에요.

```
예시: 학생별 키워드 사용 히트맵

              | 힘들다 | 우울 | 외롭다 |
--------------+--------+------+--------+
김민수 (1-2)  |   3    |  1   |   0    |  ← 숫자가 클수록 진한 빨강
이영희 (1-3)  |   0    |  2   |   1    |
박철수 (2-1)  |   5    |  0   |   2    |  ← 5가 가장 크니까 가장 진함
```

- 숫자가 0이면: 연한 회색
- 숫자가 작으면: 연한 빨강
- 숫자가 크면: 진한 빨강

---

## 📁 파일 구조

```
src/
├── components/
│   └── admin/
│       ├── MindTalkInquiry.tsx    ← 기존 마음톡 조회 컴포넌트
│       └── KeywordHeatmap.tsx     ← 새로 만들 히트맵 컴포넌트 ✨
```

---

## 🔧 구현 단계

### 1단계: 새 컴포넌트 파일 만들기

`src/components/admin/KeywordHeatmap.tsx` 파일을 새로 만들어요.

```tsx
// 1. 필요한 것들 가져오기 (import)
import React, { useMemo } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { ScrollArea, ScrollBar } from '@/components/ui/scroll-area';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { Grid3X3 } from 'lucide-react';
```

#### 💡 import 설명
| 가져오는 것 | 설명 |
|------------|------|
| `useMemo` | 복잡한 계산을 기억해두는 React 기능 |
| `Card` | 박스 모양의 UI 컴포넌트 |
| `ScrollArea` | 스크롤 가능한 영역 |
| `Tooltip` | 마우스 올리면 나타나는 설명 |
| `Grid3X3` | 격자 모양 아이콘 |

---

### 2단계: 컴포넌트가 받을 데이터 정의하기 (Props)

```tsx
// 2. Props(속성) 타입 정의하기
// = 이 컴포넌트가 부모로부터 어떤 데이터를 받을지 정하는 것
interface KeywordHeatmapProps {
  // 모든 대화 메시지 목록
  allMessages: Array<{
    student_id: string;      // 학번
    student_name: string;    // 이름
    student_grade: number;   // 학년
    student_class: number;   // 반
    student_number: number;  // 번호
    role: string;            // 'user' 또는 'assistant'
    content: string;         // 메시지 내용
  }>;
  
  // 위험 키워드 목록 (예: ['힘들다', '우울', '외롭다'])
  dangerousKeywords: string[];
  
  // 학생 클릭했을 때 실행할 함수 (선택사항)
  onStudentClick?: (
    studentId: string, 
    studentName: string, 
    grade: number, 
    classNum: number, 
    number: number
  ) => void;
}
```

#### 💡 Props란?
- **Props**는 부모 컴포넌트가 자식 컴포넌트에게 전달하는 데이터예요.
- 마치 함수의 매개변수(파라미터)와 비슷해요!

```tsx
// 예시: 부모가 자식에게 데이터 전달
<KeywordHeatmap 
  allMessages={메시지목록}      // 이런 식으로 전달!
  dangerousKeywords={키워드목록}
/>
```

---

### 3단계: 히트맵 데이터 계산하기

```tsx
const KeywordHeatmap = ({ allMessages, dangerousKeywords, onStudentClick }: KeywordHeatmapProps) => {
  
  // 3. useMemo로 복잡한 계산 결과 기억하기
  // = 메시지가 변경될 때만 다시 계산함 (성능 최적화)
  const heatmapData = useMemo(() => {
    
    // 3-1. 사용자(학생) 메시지만 골라내기
    // AI 응답(role: 'assistant')은 제외!
    const userMessages = allMessages.filter(m => m.role === 'user');
    
    // 3-2. 학생 목록 만들기 (중복 제거)
    // Map을 사용해서 같은 학생은 한 번만 저장
    const studentsMap = new Map();
    
    userMessages.forEach(msg => {
      if (!studentsMap.has(msg.student_id)) {
        studentsMap.set(msg.student_id, {
          student_id: msg.student_id,
          student_name: msg.student_name,
          student_grade: msg.student_grade,
          student_class: msg.student_class,
          student_number: msg.student_number,
        });
      }
    });
    
    // Map을 배열로 변환 후 정렬 (학년 → 반 → 번호 순)
    const students = Array.from(studentsMap.values())
      .sort((a, b) => {
        if (a.student_grade !== b.student_grade) 
          return a.student_grade - b.student_grade;
        if (a.student_class !== b.student_class) 
          return a.student_class - b.student_class;
        return a.student_number - b.student_number;
      });
    
    // 3-3. 각 학생별로 키워드 사용횟수 세기
    const data = {};  // { 학번: { 키워드: 횟수 } }
    let maxCount = 0; // 가장 많이 사용된 횟수 (색상 계산용)
    
    students.forEach(student => {
      // 이 학생의 메시지만 필터링
      const studentMessages = userMessages.filter(
        m => m.student_id === student.student_id
      );
      data[student.student_id] = {};
      
      // 각 키워드별로 몇 번 나왔는지 세기
      dangerousKeywords.forEach(keyword => {
        let count = 0;
        studentMessages.forEach(msg => {
          // 정규표현식으로 키워드 찾기 (대소문자 구분 없이)
          const regex = new RegExp(keyword, 'gi');
          const matches = msg.content.match(regex);
          if (matches) count += matches.length;
        });
        data[student.student_id][keyword] = count;
        if (count > maxCount) maxCount = count;
      });
    });
    
    // 3-4. 실제 사용된 키워드만 필터링
    const usedKeywords = dangerousKeywords.filter(keyword => 
      students.some(student => data[student.student_id][keyword] > 0)
    );
    
    // 3-5. 키워드가 있는 학생만 필터링
    const studentsWithKeywords = students.filter(student =>
      usedKeywords.some(keyword => data[student.student_id][keyword] > 0)
    );
    
    return { 
      students: studentsWithKeywords, 
      keywords: usedKeywords, 
      data, 
      maxCount 
    };
    
  }, [allMessages, dangerousKeywords]);  // 이 값들이 변경될 때만 재계산
```

#### 💡 정규표현식(RegExp) 설명
```javascript
const regex = new RegExp('힘들다', 'gi');
// 'g' = global (전체에서 찾기)
// 'i' = ignore case (대소문자 무시)

const text = "힘들다. 정말 힘들다.";
const matches = text.match(regex);
// 결과: ['힘들다', '힘들다'] - 2번 발견!
```

---

### 4단계: 색상 계산 함수 만들기

```tsx
  // 4. 횟수에 따라 색상 결정하는 함수
  const getHeatColor = (count: number, maxCount: number): string => {
    // 0이면 회색
    if (count === 0) return 'bg-gray-100';
    
    // 비율 계산 (0 ~ 1 사이 값)
    const intensity = Math.min(count / Math.max(maxCount, 1), 1);
    
    // 비율에 따라 색상 반환
    if (intensity < 0.25) return 'bg-red-100';           // 연한 빨강
    if (intensity < 0.5) return 'bg-red-300';            // 중간
    if (intensity < 0.75) return 'bg-red-500 text-white'; // 진한
    return 'bg-red-700 text-white';                       // 가장 진한
  };
```

#### 💡 색상 단계 시각화
```
횟수/최대값  |  비율   |  색상
-----------+---------+------------------
   0/5     |   0%    |  회색 (bg-gray-100)
   1/5     |  20%    |  연빨강 (bg-red-100)
   2/5     |  40%    |  중빨강 (bg-red-300)
   4/5     |  80%    |  진빨강 (bg-red-500)
   5/5     | 100%    |  가장진 (bg-red-700)
```

---

### 5단계: 화면에 표시하기 (JSX)

```tsx
  // 5. 화면 그리기
  return (
    <Card className="border-mindtalk-chat-cyan/30">
      {/* 제목 부분 */}
      <CardHeader className="py-3">
        <CardTitle className="flex items-center gap-2 text-base">
          <Grid3X3 className="h-4 w-4 text-mindtalk-chat-cyan" />
          키워드 사용 히트맵
          <span className="text-xs font-normal text-muted-foreground ml-2">
            ({heatmapData.students.length}명, {heatmapData.keywords.length}개 키워드)
          </span>
        </CardTitle>
      </CardHeader>
      
      <CardContent className="p-2">
        <TooltipProvider>
          {/* 가로 스크롤 가능한 영역 */}
          <ScrollArea className="w-full">
            <div className="min-w-max">
              
              {/* 헤더 행: 키워드 이름들 */}
              <div className="flex">
                <div className="w-28 shrink-0 p-2 text-xs font-medium">
                  학생
                </div>
                {heatmapData.keywords.map(keyword => (
                  <div key={keyword} className="w-12 shrink-0 p-1 text-center">
                    <Tooltip>
                      <TooltipTrigger asChild>
                        <span className="text-[10px] font-medium text-mindtalk-alert-red">
                          {keyword.length > 3 ? keyword.substring(0, 3) + '..' : keyword}
                        </span>
                      </TooltipTrigger>
                      <TooltipContent>
                        <p>{keyword}</p>
                      </TooltipContent>
                    </Tooltip>
                  </div>
                ))}
              </div>
              
              {/* 데이터 행: 학생별 키워드 사용횟수 */}
              {heatmapData.students.map(student => (
                <div key={student.student_id} className="flex border-t">
                  {/* 학생 이름 (클릭 가능) */}
                  <div 
                    className="w-28 shrink-0 p-2 text-xs cursor-pointer hover:bg-mindtalk-chat-cyan-light"
                    onClick={() => onStudentClick?.(
                      student.student_id, 
                      student.student_name, 
                      student.student_grade, 
                      student.student_class, 
                      student.student_number
                    )}
                  >
                    {student.student_name} ({student.student_grade}-{student.student_class})
                  </div>
                  
                  {/* 각 키워드별 셀 */}
                  {heatmapData.keywords.map(keyword => {
                    const count = heatmapData.data[student.student_id][keyword] || 0;
                    return (
                      <div
                        key={keyword}
                        className={`w-12 h-8 shrink-0 flex items-center justify-center text-xs font-medium ${getHeatColor(count, heatmapData.maxCount)}`}
                        onClick={() => count > 0 && onStudentClick?.(
                          student.student_id,
                          student.student_name,
                          student.student_grade,
                          student.student_class,
                          student.student_number
                        )}
                      >
                        {count > 0 ? count : ''}
                      </div>
                    );
                  })}
                </div>
              ))}
            </div>
            <ScrollBar orientation="horizontal" />
          </ScrollArea>
        </TooltipProvider>
        
        {/* 범례 (색상 설명) */}
        <div className="flex items-center justify-end gap-2 mt-3 text-xs text-muted-foreground">
          <span>적음</span>
          <div className="flex gap-0.5">
            <div className="w-4 h-4 bg-red-100 border" />
            <div className="w-4 h-4 bg-red-300" />
            <div className="w-4 h-4 bg-red-500" />
            <div className="w-4 h-4 bg-red-700" />
          </div>
          <span>많음</span>
        </div>
      </CardContent>
    </Card>
  );
};

export default KeywordHeatmap;
```

---

### 6단계: 기존 컴포넌트에 연결하기

`MindTalkInquiry.tsx` 파일을 수정해요.

```tsx
// 6-1. import 추가
import KeywordHeatmap from './KeywordHeatmap';

// 6-2. 컴포넌트 안에서 사용
// (학생별 대화 조회 탭 안에 추가)
<KeywordHeatmap 
  allMessages={allMessages}
  dangerousKeywords={dangerousKeywords}
  onStudentClick={(studentId, studentName, grade, classNum, number) => 
    fetchStudentMessages(studentId, studentName, grade, classNum, number)
  }
/>
```

#### 💡 onStudentClick 설명
- 히트맵에서 학생을 클릭하면 `fetchStudentMessages` 함수가 실행돼요
- 이 함수는 해당 학생의 대화 내용을 가져와서 모달창으로 보여줘요

---

## 📊 전체 데이터 흐름 정리

```
┌─────────────────────────────────────────────────────────────┐
│                   MindTalkInquiry (부모)                     │
│                                                              │
│  ┌─────────────────┐    전달     ┌──────────────────────┐   │
│  │  allMessages    │ ─────────→ │   KeywordHeatmap     │   │
│  │  (모든 대화)     │            │   (히트맵 컴포넌트)    │   │
│  └─────────────────┘            └──────────────────────┘   │
│                                            │                 │
│  ┌─────────────────┐    전달                │                │
│  │ dangerousKeywords│ ───────────────────────┘               │
│  │  (위험 키워드)    │                                        │
│  └─────────────────┘                                         │
│                                                              │
│  ┌─────────────────┐           ┌──────────────────────┐     │
│  │fetchStudentMessages│ ←────── │  onStudentClick      │     │
│  │ (대화 가져오기)    │  클릭시  │  (클릭 이벤트)        │     │
│  └─────────────────┘   호출    └──────────────────────┘     │
└─────────────────────────────────────────────────────────────┘
```

---

## 🧠 핵심 개념 복습

### 1. useMemo
```tsx
const result = useMemo(() => {
  // 복잡한 계산
  return 계산결과;
}, [의존성배열]);  // 이 값이 변할 때만 재계산
```
- 불필요한 재계산을 막아 성능을 높여요

### 2. Props (속성)
```tsx
// 부모 → 자식으로 데이터 전달
<자식컴포넌트 이름={값} />

// 자식에서 받기
const 자식컴포넌트 = ({ 이름 }) => { ... }
```

### 3. 콜백 함수 전달
```tsx
// 부모에서 함수 전달
<자식 onClick={(x) => 부모함수(x)} />

// 자식에서 실행
onClick?.()  // ?.는 함수가 있을 때만 실행
```

### 4. 조건부 스타일링
```tsx
className={`기본스타일 ${조건 ? '참스타일' : '거짓스타일'}`}
```

---

## ✏️ 연습 문제

### 문제 1: 색상 단계 추가하기
현재 4단계 색상을 6단계로 늘려보세요.

```tsx
// 힌트: getHeatColor 함수 수정
if (intensity < 0.17) return 'bg-red-50';
if (intensity < 0.33) return 'bg-red-100';
// ... 계속 추가
```

### 문제 2: 키워드 정렬 기능 추가
키워드를 사용횟수 합계 순으로 정렬해보세요.

```tsx
// 힌트: usedKeywords를 정렬할 때
usedKeywords.sort((a, b) => {
  const sumA = students.reduce((sum, s) => sum + data[s.student_id][a], 0);
  const sumB = students.reduce((sum, s) => sum + data[s.student_id][b], 0);
  return sumB - sumA;  // 내림차순
});
```

### 문제 3: 학생 합계 열 추가
각 학생의 키워드 사용 총합을 보여주는 열을 추가해보세요.

---

## 📝 오늘 배운 것 정리

| 개념 | 설명 | 사용 예 |
|------|------|---------|
| 히트맵 | 데이터를 색상으로 시각화 | 키워드 사용횟수 표시 |
| useMemo | 계산 결과 캐싱 | 복잡한 통계 계산 |
| Props | 부모→자식 데이터 전달 | allMessages 전달 |
| 콜백 Props | 자식→부모 이벤트 전달 | onStudentClick |
| 정규표현식 | 문자열 패턴 매칭 | 키워드 찾기 |

---

**작성일**: 2025-12-17  
**관련 파일**: 
- `src/components/admin/KeywordHeatmap.tsx`
- `src/components/admin/MindTalkInquiry.tsx`
