# 2025년 12월 15일 코드 수정 가이드

## 📚 오늘 배울 내용
1. 그룹 멤버(학생) 수정 기능 추가하기
2. 로그인 후 이동 경로 통일하기
3. **실시간 동기화 (Realtime) 구현하기** ⭐
4. **상벌점 테이블 실시간 동기화** ⭐
5. **실시간 동기화 시 토스트 알림 추가** ⭐
6. **관리자 대시보드 실시간 동기화** ⭐ 새로운 내용!

---

## 1. 그룹 멤버(학생) 수정 기능

### 🎯 목표
기존에 저장된 학생 그룹에서 학생을 추가하거나 삭제할 수 있는 기능을 만듭니다.

### 📝 개념 설명

**상태(State)란?**
React에서 화면에 보여지는 데이터를 저장하는 공간입니다. 상태가 바뀌면 화면도 자동으로 바뀝니다.

**편집 모드란?**
"지금 수정 중이에요"라고 알려주는 상태입니다. 편집 모드일 때는 다른 버튼들이 비활성화됩니다.

---

### 💻 코드 작성하기

#### Step 1: 새로운 상태 추가하기

```typescript
// 어떤 그룹의 멤버를 수정 중인지 저장하는 상태
const [editingMembersGroupId, setEditingMembersGroupId] = useState<string | null>(null);

// 수정 중인 그룹의 전체 정보를 저장하는 상태
const [editingMembersGroup, setEditingMembersGroup] = useState<StudentGroup | null>(null);
```

**쉽게 이해하기:**
- `editingMembersGroupId`: 수정 중인 그룹의 ID (고유번호)
- `editingMembersGroup`: 수정 중인 그룹의 모든 정보 (이름, 학생 목록 등)
- `null`은 "아무것도 없음"을 의미합니다

---

#### Step 2: 멤버 수정 시작 함수

```typescript
const handleStartEditMembers = (group: StudentGroup) => {
  // 1. 수정할 그룹의 ID 저장
  setEditingMembersGroupId(group.id);
  
  // 2. 수정할 그룹의 전체 정보 저장
  setEditingMembersGroup(group);
  
  // 3. 현재 그룹에 있는 학생들을 선택된 상태로 만들기
  setSelectedStudents(group.student_ids);
  
  // 4. 불러온 학생 목록 초기화 (혼란 방지)
  setLoadedGroupStudents([]);
};
```

**쉽게 이해하기:**
- 이 함수는 "멤버수정" 버튼을 클릭하면 실행됩니다
- 그룹에 이미 있는 학생들은 자동으로 체크박스가 선택됩니다

---

#### Step 3: 멤버 수정 취소 함수

```typescript
const handleCancelEditMembers = () => {
  // 모든 상태를 초기화
  setEditingMembersGroupId(null);
  setEditingMembersGroup(null);
  setSelectedStudents([]);
};
```

**쉽게 이해하기:**
- "취소" 버튼을 누르면 수정 모드에서 나갑니다
- 선택한 학생들도 모두 해제됩니다

---

#### Step 4: 멤버 수정 저장 함수 (가장 중요!)

```typescript
const handleSaveEditMembers = async () => {
  // 1. 수정 중인 그룹이 없으면 함수 종료
  if (!editingMembersGroupId) return;
  
  // 2. 최소 1명의 학생이 선택되어야 함
  if (selectedStudents.length === 0) {
    toast.error("최소 1명의 학생을 선택해주세요.");
    return;
  }

  try {
    // 3. 데이터베이스에 변경사항 저장
    const { error } = await supabase
      .from('student_groups')           // student_groups 테이블에서
      .update({ student_ids: selectedStudents })  // student_ids를 업데이트
      .eq('id', editingMembersGroupId); // 해당 그룹 ID와 일치하는 행만

    if (error) throw error;

    // 4. 화면에 보이는 그룹 목록도 업데이트
    setGroups(groups.map(group => 
      group.id === editingMembersGroupId 
        ? { ...group, student_ids: selectedStudents }  // 수정된 그룹
        : group  // 다른 그룹은 그대로
    ));
    
    // 5. 성공 메시지 표시
    toast.success(`그룹 멤버가 수정되었습니다. (${selectedStudents.length}명)`);
    
    // 6. 편집 모드 종료
    handleCancelEditMembers();
  } catch (error) {
    toast.error("멤버 수정에 실패했습니다.");
  }
};
```

**쉽게 이해하기:**

1. **Supabase 업데이트 문법:**
```typescript
supabase
  .from('테이블이름')      // 어떤 테이블?
  .update({ 컬럼: 값 })    // 무엇을 바꿀까?
  .eq('id', 그룹ID)        // 어떤 행을?
```

2. **map() 함수로 배열 수정하기:**
```typescript
// 배열의 각 항목을 하나씩 확인하면서 새 배열을 만듭니다
groups.map(group => 
  group.id === 수정할ID 
    ? { ...group, student_ids: 새로운학생목록 }  // 조건이 맞으면 수정
    : group                                       // 아니면 그대로
)
```

3. **스프레드 연산자 `...`:**
```typescript
{ ...group, student_ids: 새값 }
// group의 모든 속성을 복사하고, student_ids만 새 값으로 바꿈
```

---

#### Step 5: 화면(UI) 구성하기

**멤버 수정 중일 때 보여주는 안내 카드:**

```tsx
{editingMembersGroup && (
  <Card className="p-3 border-orange-500 bg-orange-50">
    <div className="flex items-center justify-between">
      <div className="flex items-center gap-2 text-sm font-medium text-orange-700">
        <UserPlus size={16} />
        <span>"{editingMembersGroup.group_name}" 그룹 멤버 수정 중</span>
      </div>
      <div className="flex gap-2">
        <Button size="sm" variant="outline" onClick={handleCancelEditMembers}>
          취소
        </Button>
        <Button size="sm" onClick={handleSaveEditMembers}>
          저장 ({selectedStudents.length}명)
        </Button>
      </div>
    </div>
  </Card>
)}
```

**쉽게 이해하기:**
- `{조건 && <컴포넌트/>}`: 조건이 참일 때만 컴포넌트를 보여줍니다
- `border-orange-500`: 주황색 테두리로 "수정 중"임을 강조합니다

---

**멤버수정 버튼 추가하기:**

```tsx
<Button
  size="sm"
  variant="outline"
  onClick={() => handleStartEditMembers(group)}
  disabled={editingGroupId !== null || editingMembersGroupId !== null}
  className="text-orange-600 border-orange-600 hover:bg-orange-50"
>
  <UserPlus size={12} className="mr-1" />
  멤버수정
</Button>
```

**쉽게 이해하기:**
- `disabled={조건}`: 조건이 참이면 버튼을 클릭할 수 없게 만듭니다
- 다른 그룹을 수정 중일 때는 비활성화됩니다

---

## 2. 로그인 후 이동 경로 통일하기

### 🎯 목표
관리자 권한이 있든 없든, 모든 교사는 로그인하면 교사 대시보드로 이동합니다.

### 📝 변경 전 코드

```typescript
// 관리자면 관리자 대시보드로, 아니면 교사 대시보드로
if (user.isAdmin) {
  navigate("/admin/dashboard");
} else {
  navigate("/teacher/dashboard");
}
```

### ✅ 변경 후 코드

```typescript
// 교사는 항상 교사 대시보드로 이동 (관리자 권한 여부 무관)
navigate("/teacher/dashboard");
```

**쉽게 이해하기:**
- 조건문 `if-else`를 삭제하고 하나의 경로만 남겼습니다
- 관리자 교사도 교사 대시보드를 먼저 보고, 필요하면 관리자 대시보드 버튼을 클릭합니다

---

## 3. 실시간 동기화 (Realtime) 구현하기 ⭐

### 🎯 목표
여러 브라우저에서 같은 교사가 로그인했을 때, 한 브라우저에서 그룹을 수정하면 다른 브라우저에서도 자동으로 업데이트되게 합니다.

### 🤔 문제 상황

```
[브라우저 1] 그룹 멤버 5명 → 6명으로 수정
[브라우저 2] 여전히 5명으로 표시됨 (새로고침 전까지)
```

**왜 이런 문제가 생길까요?**
- 브라우저 1에서 수정하면 → 데이터베이스는 업데이트됨
- 브라우저 2는 처음 페이지를 열 때만 데이터를 가져옴
- 브라우저 2는 데이터베이스가 바뀐 걸 모름!

### 📝 해결 방법 2가지

1. **실시간 구독 (Realtime Subscription)**: 데이터베이스 변경을 자동으로 감지
2. **페이지 포커스 감지**: 탭을 다시 클릭하면 데이터 새로고침

---

### 💻 코드 작성하기

#### 방법 1: 페이지 포커스 시 새로고침

```typescript
useEffect(() => {
  // 탭이 다시 보이게 되면 실행
  const handleVisibilityChange = () => {
    if (document.visibilityState === 'visible') {
      loadGroups();  // 그룹 목록 다시 불러오기
    }
  };

  // 윈도우에 포커스가 오면 실행
  const handleFocus = () => {
    loadGroups();
  };

  // 이벤트 리스너 등록
  document.addEventListener('visibilitychange', handleVisibilityChange);
  window.addEventListener('focus', handleFocus);

  // 컴포넌트가 사라질 때 이벤트 리스너 제거 (메모리 누수 방지)
  return () => {
    document.removeEventListener('visibilitychange', handleVisibilityChange);
    window.removeEventListener('focus', handleFocus);
  };
}, []);
```

**쉽게 이해하기:**

| 용어 | 설명 | 예시 |
|------|------|------|
| `visibilitychange` | 탭이 보이거나 숨겨질 때 발생 | 다른 탭에서 돌아올 때 |
| `focus` | 윈도우가 활성화될 때 발생 | 다른 프로그램에서 돌아올 때 |
| `addEventListener` | "이 이벤트가 발생하면 이 함수를 실행해줘" | 이벤트 감시 시작 |
| `removeEventListener` | "더 이상 감시하지 마" | 이벤트 감시 종료 |

**왜 `return`에서 리스너를 제거할까요?**
```typescript
return () => {
  document.removeEventListener('visibilitychange', handleVisibilityChange);
};
```
- 컴포넌트가 사라져도 이벤트 리스너가 남아있으면 → 메모리 낭비!
- 마치 방을 나갈 때 불을 끄는 것과 같습니다 💡

---

#### 방법 2: 실시간 구독 (Supabase Realtime)

```typescript
useEffect(() => {
  // 로그인한 사용자 정보 가져오기
  const authUser = localStorage.getItem("auth_user");
  if (!authUser) return;

  const user = JSON.parse(authUser);

  // 실시간 채널 생성 및 구독
  const channel = supabase
    .channel('student_groups_changes')  // 채널 이름 (자유롭게 지정)
    .on(
      'postgres_changes',  // PostgreSQL 변경사항 감지
      {
        event: '*',        // 모든 이벤트 (INSERT, UPDATE, DELETE)
        schema: 'public',  // public 스키마
        table: 'student_groups',  // 감시할 테이블
        filter: `admin_id=eq.${user.id}`  // 내가 만든 그룹만
      },
      (payload) => {
        console.log('변경 감지됨:', payload);
        loadGroups();  // 변경 감지 시 그룹 목록 새로고침
      }
    )
    .subscribe();  // 구독 시작!

  // 컴포넌트가 사라질 때 구독 해제
  return () => {
    supabase.removeChannel(channel);
  };
}, []);
```

**쉽게 이해하기:**

```
[데이터베이스]  ─────────────────────────────────────────>
       │                                                
       │  "student_groups 테이블이 바뀌었어!"            
       │                                                
       ▼                                                
[Supabase Realtime 서버]                                
       │                                                
       │  "구독 중인 모든 브라우저에게 알려줘!"          
       │                                                
       ├──────────────> [브라우저 1] loadGroups() 실행!
       │                                                
       └──────────────> [브라우저 2] loadGroups() 실행!
```

**코드 분석:**

| 코드 | 의미 |
|------|------|
| `.channel('이름')` | 실시간 채널 생성 (라디오 주파수처럼) |
| `.on('postgres_changes', ...)` | PostgreSQL 변경사항 감지 설정 |
| `event: '*'` | 모든 종류의 변경 감지 (추가/수정/삭제) |
| `event: 'INSERT'` | 새 데이터 추가만 감지 |
| `event: 'UPDATE'` | 데이터 수정만 감지 |
| `event: 'DELETE'` | 데이터 삭제만 감지 |
| `filter: \`admin_id=eq.${user.id}\`` | 내 그룹만 필터링 |
| `.subscribe()` | 구독 시작 (라디오 켜기) |
| `supabase.removeChannel(channel)` | 구독 해제 (라디오 끄기) |

---

### 🖼️ 실시간 동기화 흐름도

```
┌─────────────────────────────────────────────────────────────┐
│                        데이터베이스                          │
│                    (student_groups 테이블)                   │
└─────────────────────────────────────────────────────────────┘
                              │
                              │ 변경 발생!
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                   Supabase Realtime 서버                     │
│              "구독자들에게 변경사항 알림"                     │
└─────────────────────────────────────────────────────────────┘
                              │
           ┌──────────────────┼──────────────────┐
           │                  │                  │
           ▼                  ▼                  ▼
    ┌───────────┐      ┌───────────┐      ┌───────────┐
    │ 브라우저1  │      │ 브라우저2  │      │ 브라우저3  │
    │ loadGroups│      │ loadGroups│      │ loadGroups│
    │ 자동 실행 │      │ 자동 실행 │      │ 자동 실행 │
    └───────────┘      └───────────┘      └───────────┘
```

---

### ⚠️ 주의사항

1. **구독 해제 필수!**
   - 컴포넌트가 사라질 때 `removeChannel()`을 호출해야 합니다
   - 안 하면 메모리 누수가 발생합니다

2. **필터 사용하기**
   - `filter`를 사용하면 필요한 데이터만 받을 수 있습니다
   - 모든 데이터를 받으면 불필요한 트래픽이 발생합니다

3. **채널 이름은 고유하게**
   - 같은 이름의 채널을 여러 번 만들면 문제가 생길 수 있습니다

---

## 🧪 실습 과제

### 과제 1: 코드 이해하기
다음 코드가 무엇을 하는지 설명해보세요:

```typescript
setGroups(groups.map(group => 
  group.id === editingMembersGroupId 
    ? { ...group, student_ids: selectedStudents }
    : group
));
```

<details>
<summary>정답 보기</summary>

1. `groups` 배열의 모든 그룹을 하나씩 확인합니다
2. 그룹의 ID가 수정 중인 그룹 ID와 같으면:
   - 그 그룹의 모든 정보를 복사하고 (`...group`)
   - `student_ids`만 새로운 학생 목록으로 바꿉니다
3. ID가 다르면 그 그룹은 그대로 유지합니다
4. 새로 만들어진 배열을 `setGroups`로 저장합니다

</details>

---

### 과제 2: Supabase 쿼리 작성하기
"merits" 테이블에서 `score`를 10으로 바꾸는 코드를 작성해보세요.
조건: `id`가 "abc123"인 행만 수정

<details>
<summary>정답 보기</summary>

```typescript
const { error } = await supabase
  .from('merits')
  .update({ score: 10 })
  .eq('id', 'abc123');
```

</details>

---

### 과제 3: 조건부 렌더링 이해하기
다음 코드에서 화면에 "안녕하세요"가 보이려면 어떤 조건이 필요할까요?

```tsx
{isLoggedIn && <p>안녕하세요</p>}
```

<details>
<summary>정답 보기</summary>

`isLoggedIn`이 `true`여야 합니다.
`&&` 연산자는 왼쪽이 참(true)일 때만 오른쪽을 보여줍니다.

</details>

---

### 과제 4: 실시간 구독 코드 작성하기 ⭐ 새로운 과제!
"merits" 테이블의 변경사항을 실시간으로 감지하는 코드를 작성해보세요.

<details>
<summary>정답 보기</summary>

```typescript
useEffect(() => {
  const channel = supabase
    .channel('merits_changes')
    .on(
      'postgres_changes',
      {
        event: '*',
        schema: 'public',
        table: 'merits'
      },
      (payload) => {
        console.log('상벌점 변경:', payload);
        // 데이터 새로고침 함수 호출
      }
    )
    .subscribe();

  return () => {
    supabase.removeChannel(channel);
  };
}, []);
```

</details>

---

### 과제 5: 이벤트 리스너 이해하기 ⭐ 새로운 과제!
다음 코드에서 `return` 부분이 왜 필요한지 설명해보세요.

```typescript
useEffect(() => {
  window.addEventListener('focus', handleFocus);
  
  return () => {
    window.removeEventListener('focus', handleFocus);
  };
}, []);
```

<details>
<summary>정답 보기</summary>

`return` 부분은 **cleanup 함수**입니다.

1. 컴포넌트가 화면에서 사라질 때 실행됩니다
2. 등록했던 이벤트 리스너를 제거합니다
3. 이렇게 하지 않으면:
   - 이벤트 리스너가 계속 남아있음
   - 메모리 누수 발생
   - 같은 함수가 여러 번 실행될 수 있음

마치 방을 나갈 때 불을 끄는 것과 같습니다! 💡

</details>

---

## 4. 상벌점(merits, demerits, monthly) 실시간 동기화 ⭐

### 🎯 목표
교사가 상벌점을 입력하면, 해당 학생의 화면에서 자동으로 업데이트되게 합니다.
교사 화면에서도 본인이 입력한 상벌점 목록이 실시간으로 갱신됩니다.

### 🤔 적용 대상
1. **교사 대시보드** (`TeacherRecordsList.tsx`): 본인이 부여한 상벌점 목록
2. **학생 대시보드** (`Dashboard.tsx`): 본인이 받은 상벌점 목록

---

### 💻 교사 대시보드 실시간 동기화 코드

#### Step 1: 페이지 포커스 시 새로고침

```typescript
// 페이지 포커스/가시성 변경 시 데이터 새로고침
useEffect(() => {
  const handleVisibilityChange = () => {
    if (document.visibilityState === 'visible') {
      loadRecords();  // 상벌점 목록 다시 불러오기
    }
  };

  const handleFocus = () => {
    loadRecords();
  };

  document.addEventListener('visibilitychange', handleVisibilityChange);
  window.addEventListener('focus', handleFocus);

  return () => {
    document.removeEventListener('visibilitychange', handleVisibilityChange);
    window.removeEventListener('focus', handleFocus);
  };
}, []);
```

---

#### Step 2: merits, demerits, monthly 테이블 실시간 구독

```typescript
// 실시간 동기화 - 상점(merits) 테이블
useEffect(() => {
  if (!teacherId) return;

  const meritsChannel = supabase
    .channel('teacher_merits_changes')
    .on(
      'postgres_changes',
      {
        event: '*',           // 모든 이벤트 감지
        schema: 'public',
        table: 'merits',
        filter: `teacher_id=eq.${teacherId}`  // 내가 부여한 상점만
      },
      (payload) => {
        console.log('Merits changed:', payload);
        loadRecords();  // 데이터 새로고침
      }
    )
    .subscribe();

  return () => {
    supabase.removeChannel(meritsChannel);
  };
}, [teacherId]);
```

**벌점(demerits)도 같은 방식으로:**

```typescript
// 실시간 동기화 - 벌점(demerits) 테이블
useEffect(() => {
  if (!teacherId) return;

  const demeritsChannel = supabase
    .channel('teacher_demerits_changes')
    .on(
      'postgres_changes',
      {
        event: '*',
        schema: 'public',
        table: 'demerits',
        filter: `teacher_id=eq.${teacherId}`
      },
      (payload) => {
        console.log('Demerits changed:', payload);
        loadRecords();
      }
    )
    .subscribe();

  return () => {
    supabase.removeChannel(demeritsChannel);
  };
}, [teacherId]);
```

**이달의 학생(monthly)도 같은 방식으로:**

```typescript
// 실시간 동기화 - 이달의 학생(monthly) 테이블
useEffect(() => {
  if (!teacherId) return;

  const monthlyChannel = supabase
    .channel('teacher_monthly_changes')
    .on(
      'postgres_changes',
      {
        event: '*',
        schema: 'public',
        table: 'monthly',
        filter: `teacher_id=eq.${teacherId}`
      },
      (payload) => {
        console.log('Monthly changed:', payload);
        loadRecords();
      }
    )
    .subscribe();

  return () => {
    supabase.removeChannel(monthlyChannel);
  };
}, [teacherId]);
```

---

### 💻 학생 대시보드 실시간 동기화 코드

학생 화면에서는 `student_id`로 필터링합니다:

```typescript
// 실시간 동기화 - 상점(merits) 테이블
useEffect(() => {
  const authUser = localStorage.getItem("auth_user");
  if (!authUser) return;

  const user = JSON.parse(authUser);
  if (!user.studentId) return;

  const meritsChannel = supabase
    .channel('student_merits_changes')
    .on(
      'postgres_changes',
      {
        event: '*',
        schema: 'public',
        table: 'merits',
        filter: `student_id=eq.${user.studentId}`  // 내가 받은 상점만
      },
      (payload) => {
        console.log('Student merits changed:', payload);
        fetchStudentData(user.studentId);  // 데이터 새로고침
      }
    )
    .subscribe();

  return () => {
    supabase.removeChannel(meritsChannel);
  };
}, []);
```

**쉽게 이해하기:**
- 교사: `filter: \`teacher_id=eq.${teacherId}\`` → 내가 부여한 상벌점
- 학생: `filter: \`student_id=eq.${user.studentId}\`` → 내가 받은 상벌점

---

## 5. 실시간 동기화 시 토스트 알림 표시 🔔

### 🎯 목표
데이터가 실시간으로 변경될 때, 사용자에게 알림 메시지를 보여줍니다.

### 📝 개념 설명

**토스트(Toast)란?**
- 화면 한쪽에 잠깐 나타났다 사라지는 알림 메시지
- 사용자의 작업을 방해하지 않으면서 정보 전달

**payload.eventType이란?**
- Supabase Realtime이 보내주는 변경 유형 정보
- `INSERT`: 새 데이터 추가됨
- `UPDATE`: 기존 데이터 수정됨
- `DELETE`: 데이터 삭제됨

---

### 💻 교사 대시보드 토스트 알림 코드

```typescript
// 실시간 동기화 - 상점 테이블 (토스트 알림 포함)
const meritsChannel = supabase
  .channel('teacher_merits_changes')
  .on(
    'postgres_changes',
    {
      event: '*',
      schema: 'public',
      table: 'merits',
      filter: `teacher_id=eq.${teacherId}`
    },
    (payload) => {
      console.log('Merits changed:', payload);
      loadRecords();
      
      // 토스트 알림 표시
      if (payload.eventType === 'INSERT') {
        toast.info('🔄 상점이 추가되었습니다');
      } else if (payload.eventType === 'UPDATE') {
        toast.info('🔄 상점이 수정되었습니다');
      } else if (payload.eventType === 'DELETE') {
        toast.info('🔄 상점이 삭제되었습니다');
      }
    }
  )
  .subscribe();
```

**벌점(demerits):**

```typescript
(payload) => {
  console.log('Demerits changed:', payload);
  loadRecords();
  
  if (payload.eventType === 'INSERT') {
    toast.info('🔄 벌점이 추가되었습니다');
  } else if (payload.eventType === 'UPDATE') {
    toast.info('🔄 벌점이 수정되었습니다');
  } else if (payload.eventType === 'DELETE') {
    toast.info('🔄 벌점이 삭제되었습니다');
  }
}
```

**이달의 학생(monthly):**

```typescript
(payload) => {
  console.log('Monthly changed:', payload);
  loadRecords();
  
  if (payload.eventType === 'INSERT') {
    toast.info('🔄 이달의 학생이 추가되었습니다');
  } else if (payload.eventType === 'UPDATE') {
    toast.info('🔄 이달의 학생이 수정되었습니다');
  } else if (payload.eventType === 'DELETE') {
    toast.info('🔄 이달의 학생이 삭제되었습니다');
  }
}
```

---

### 💻 학생 대시보드 토스트 알림 코드

학생에게는 더 친절하고 구체적인 메시지를 보여줍니다:

```typescript
// 상점 알림 (학생용)
(payload) => {
  console.log('Student merits changed:', payload);
  fetchStudentData(user.studentId);
  
  if (payload.eventType === 'INSERT') {
    toast.success('🎉 새로운 상점이 부여되었습니다!');
  } else if (payload.eventType === 'UPDATE') {
    toast.info('🔄 상점 내역이 수정되었습니다');
  } else if (payload.eventType === 'DELETE') {
    toast.info('🔄 상점 내역이 삭제되었습니다');
  }
}

// 벌점 알림 (학생용)
(payload) => {
  console.log('Student demerits changed:', payload);
  fetchStudentData(user.studentId);
  
  if (payload.eventType === 'INSERT') {
    toast.warning('⚠️ 새로운 벌점이 부여되었습니다');
  } else if (payload.eventType === 'UPDATE') {
    toast.info('🔄 벌점 내역이 수정되었습니다');
  } else if (payload.eventType === 'DELETE') {
    toast.info('🔄 벌점 내역이 삭제되었습니다');
  }
}

// 이달의 학생 알림 (학생용)
(payload) => {
  console.log('Student monthly changed:', payload);
  fetchStudentData(user.studentId);
  
  if (payload.eventType === 'INSERT') {
    toast.success('🌟 이달의 학생으로 추천되었습니다!');
  } else if (payload.eventType === 'UPDATE') {
    toast.info('🔄 이달의 학생 내역이 수정되었습니다');
  } else if (payload.eventType === 'DELETE') {
    toast.info('🔄 이달의 학생 내역이 삭제되었습니다');
  }
}
```

**쉽게 이해하기:**

| toast 메서드 | 의미 | 색상 |
|-------------|------|------|
| `toast.success()` | 성공/좋은 소식 | 초록색 |
| `toast.info()` | 정보 알림 | 파란색 |
| `toast.warning()` | 주의/경고 | 노란색 |
| `toast.error()` | 오류 발생 | 빨간색 |

---

### 🖼️ 실시간 알림 흐름도

```
┌─────────────────────────────────────────────────────────────┐
│              교사가 학생에게 상점 부여                        │
│                     (INSERT 발생)                            │
└─────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────┐
│                   Supabase Realtime 서버                     │
│           "merits 테이블에 INSERT 발생했어!"                  │
└─────────────────────────────────────────────────────────────┘
                               │
            ┌──────────────────┴──────────────────┐
            │                                      │
            ▼                                      ▼
   ┌─────────────────┐                    ┌─────────────────┐
   │   교사 화면      │                    │   학생 화면      │
   │                 │                    │                 │
   │ loadRecords()   │                    │fetchStudentData()│
   │ 🔄 상점이       │                    │ 🎉 새로운 상점이 │
   │ 추가되었습니다   │                    │ 부여되었습니다!  │
   └─────────────────┘                    └─────────────────┘
```

---

## 🧪 추가 실습 과제

### 과제 6: 토스트 알림 조건문 작성하기

다음 빈칸을 채워서 DELETE 이벤트일 때 경고 메시지를 표시하는 코드를 완성하세요:

```typescript
if (payload.eventType === 'INSERT') {
  toast.success('데이터가 추가되었습니다');
} else if (payload.eventType === '______') {
  toast.info('데이터가 수정되었습니다');
} else if (payload.eventType === '______') {
  toast.______('데이터가 삭제되었습니다');
}
```

<details>
<summary>정답 보기</summary>

```typescript
if (payload.eventType === 'INSERT') {
  toast.success('데이터가 추가되었습니다');
} else if (payload.eventType === 'UPDATE') {
  toast.info('데이터가 수정되었습니다');
} else if (payload.eventType === 'DELETE') {
  toast.warning('데이터가 삭제되었습니다');
}
```

</details>

---

### 과제 7: 여러 테이블 실시간 구독하기

`merits`와 `demerits` 두 테이블을 각각 구독하는 코드를 작성해보세요.
(힌트: `useEffect`를 두 번 사용하거나, 하나의 `useEffect` 안에 두 개의 채널을 만듭니다)

<details>
<summary>정답 보기</summary>

```typescript
useEffect(() => {
  const meritsChannel = supabase
    .channel('merits_changes')
    .on('postgres_changes', 
      { event: '*', schema: 'public', table: 'merits' },
      (payload) => { loadRecords(); }
    )
    .subscribe();

  const demeritsChannel = supabase
    .channel('demerits_changes')
    .on('postgres_changes', 
      { event: '*', schema: 'public', table: 'demerits' },
      (payload) => { loadRecords(); }
    )
    .subscribe();

  return () => {
    supabase.removeChannel(meritsChannel);
    supabase.removeChannel(demeritsChannel);
  };
}, []);
```

</details>

---

## 6. 관리자 대시보드 실시간 동기화 ⭐ 새로운 내용!

### 🎯 목표
관리자 대시보드에서도 상벌점 데이터가 변경되면 자동으로 갱신되게 합니다.
- **상점 조회 (PointsInquiry)**: 반별 상벌점 현황 자동 갱신
- **학생 리더보드 (StudentLeaderboard)**: 순위표 자동 갱신

### 🤔 관리자 대시보드의 특징

관리자는 **모든 학생의 데이터**를 볼 수 있으므로, 필터 없이 테이블 전체의 변경을 감지합니다:

```
교사 화면: filter: `teacher_id=eq.${teacherId}` → 내 데이터만
학생 화면: filter: `student_id=eq.${studentId}` → 내 데이터만
관리자 화면: filter 없음 → 모든 데이터 감지
```

---

### 💻 상점 조회 (PointsInquiry) 실시간 동기화 코드

#### Step 1: 페이지 포커스 시 새로고침

```typescript
// 페이지 포커스 시 데이터 새로고침
useEffect(() => {
  const handleVisibilityChange = () => {
    if (document.visibilityState === 'visible' && students.length > 0) {
      handleQuery();  // 현재 조회된 데이터가 있으면 새로고침
    }
  };

  const handleFocus = () => {
    if (students.length > 0) {
      handleQuery();
    }
  };

  document.addEventListener('visibilitychange', handleVisibilityChange);
  window.addEventListener('focus', handleFocus);

  return () => {
    document.removeEventListener('visibilitychange', handleVisibilityChange);
    window.removeEventListener('focus', handleFocus);
  };
}, [students.length, grade, classNum]);  // 의존성 배열에 조건 추가
```

**쉽게 이해하기:**
- `students.length > 0`: 이미 조회한 데이터가 있을 때만 새로고침
- `grade, classNum`: 현재 선택된 학년/반 정보

---

#### Step 2: 세 테이블 모두 실시간 구독

```typescript
// 실시간 동기화 - merits, demerits, monthly 테이블
useEffect(() => {
  // 상점(merits) 채널
  const meritsChannel = supabase
    .channel('admin_merits_changes')
    .on(
      'postgres_changes',
      { event: '*', schema: 'public', table: 'merits' },  // 필터 없음!
      (payload) => {
        console.log('Admin - Merits changed:', payload);
        if (students.length > 0) {
          handleQuery();  // 데이터 새로고침
        }
        // 토스트 알림
        if (payload.eventType === 'INSERT') {
          toast.info('🔄 상점이 추가되었습니다');
        } else if (payload.eventType === 'UPDATE') {
          toast.info('🔄 상점이 수정되었습니다');
        } else if (payload.eventType === 'DELETE') {
          toast.info('🔄 상점이 삭제되었습니다');
        }
      }
    )
    .subscribe();

  // 벌점(demerits) 채널
  const demeritsChannel = supabase
    .channel('admin_demerits_changes')
    .on(
      'postgres_changes',
      { event: '*', schema: 'public', table: 'demerits' },
      (payload) => {
        console.log('Admin - Demerits changed:', payload);
        if (students.length > 0) {
          handleQuery();
        }
        if (payload.eventType === 'INSERT') {
          toast.info('🔄 벌점이 추가되었습니다');
        } else if (payload.eventType === 'UPDATE') {
          toast.info('🔄 벌점이 수정되었습니다');
        } else if (payload.eventType === 'DELETE') {
          toast.info('🔄 벌점이 삭제되었습니다');
        }
      }
    )
    .subscribe();

  // 이달의 학생(monthly) 채널
  const monthlyChannel = supabase
    .channel('admin_monthly_changes')
    .on(
      'postgres_changes',
      { event: '*', schema: 'public', table: 'monthly' },
      (payload) => {
        console.log('Admin - Monthly changed:', payload);
        if (students.length > 0) {
          handleQuery();
        }
        if (payload.eventType === 'INSERT') {
          toast.info('🔄 이달의 학생이 추가되었습니다');
        } else if (payload.eventType === 'UPDATE') {
          toast.info('🔄 이달의 학생이 수정되었습니다');
        } else if (payload.eventType === 'DELETE') {
          toast.info('🔄 이달의 학생이 삭제되었습니다');
        }
      }
    )
    .subscribe();

  // Cleanup: 세 채널 모두 제거
  return () => {
    supabase.removeChannel(meritsChannel);
    supabase.removeChannel(demeritsChannel);
    supabase.removeChannel(monthlyChannel);
  };
}, [students.length, grade, classNum]);
```

**쉽게 이해하기:**
- 관리자는 모든 데이터를 볼 수 있으므로 `filter` 옵션이 없습니다
- 세 개의 채널을 각각 만들어서 세 테이블의 변경을 모두 감지합니다
- Cleanup 함수에서 세 채널 모두 제거해야 메모리 누수가 없습니다

---

### 💻 학생 리더보드 (StudentLeaderboard) 실시간 동기화 코드

리더보드는 순위가 중요하므로, 데이터 변경 시 순위가 갱신됨을 알립니다:

```typescript
// 실시간 동기화 - 리더보드용
useEffect(() => {
  const meritsChannel = supabase
    .channel('leaderboard_merits_changes')
    .on(
      'postgres_changes',
      { event: '*', schema: 'public', table: 'merits' },
      (payload) => {
        console.log('Leaderboard - Merits changed:', payload);
        loadLeaderboard();  // 순위 새로고침
        
        // 선택된 학생이 있으면 월별 추이도 갱신
        if (selectedStudent) {
          loadMonthlyTrend(selectedStudent);
        }
        
        if (payload.eventType === 'INSERT') {
          toast.info('🔄 상점이 추가되어 순위가 갱신됩니다');
        } else if (payload.eventType === 'UPDATE') {
          toast.info('🔄 상점이 수정되어 순위가 갱신됩니다');
        } else if (payload.eventType === 'DELETE') {
          toast.info('🔄 상점이 삭제되어 순위가 갱신됩니다');
        }
      }
    )
    .subscribe();

  const demeritsChannel = supabase
    .channel('leaderboard_demerits_changes')
    .on(
      'postgres_changes',
      { event: '*', schema: 'public', table: 'demerits' },
      (payload) => {
        loadLeaderboard();
        if (selectedStudent) {
          loadMonthlyTrend(selectedStudent);
        }
        if (payload.eventType === 'INSERT') {
          toast.info('🔄 벌점이 추가되어 순위가 갱신됩니다');
        } else if (payload.eventType === 'UPDATE') {
          toast.info('🔄 벌점이 수정되어 순위가 갱신됩니다');
        } else if (payload.eventType === 'DELETE') {
          toast.info('🔄 벌점이 삭제되어 순위가 갱신됩니다');
        }
      }
    )
    .subscribe();

  const monthlyChannel = supabase
    .channel('leaderboard_monthly_changes')
    .on(
      'postgres_changes',
      { event: '*', schema: 'public', table: 'monthly' },
      (payload) => {
        loadLeaderboard();
        if (payload.eventType === 'INSERT') {
          toast.info('🔄 이달의 학생이 추가되어 순위가 갱신됩니다');
        } else if (payload.eventType === 'UPDATE') {
          toast.info('🔄 이달의 학생이 수정되어 순위가 갱신됩니다');
        } else if (payload.eventType === 'DELETE') {
          toast.info('🔄 이달의 학생이 삭제되어 순위가 갱신됩니다');
        }
      }
    )
    .subscribe();

  return () => {
    supabase.removeChannel(meritsChannel);
    supabase.removeChannel(demeritsChannel);
    supabase.removeChannel(monthlyChannel);
  };
}, [selectedStudent]);  // selectedStudent가 바뀌면 채널 재구독
```

**쉽게 이해하기:**
- `loadMonthlyTrend(selectedStudent)`: 월별 추이 차트도 함께 갱신
- 메시지에 "순위가 갱신됩니다"를 추가하여 리더보드임을 강조

---

### 🖼️ 관리자 실시간 동기화 흐름도

```
┌─────────────────────────────────────────────────────────────┐
│                 교사가 상벌점 부여                            │
│           (merits/demerits 테이블 INSERT)                    │
└─────────────────────────────────────────────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────┐
│                   Supabase Realtime 서버                     │
│              "구독자들에게 변경사항 알림"                      │
└─────────────────────────────────────────────────────────────┘
                               │
         ┌─────────────────────┼─────────────────────┐
         │                     │                     │
         ▼                     ▼                     ▼
┌─────────────────┐   ┌─────────────────┐   ┌─────────────────┐
│   교사 화면      │   │   학생 화면      │   │  관리자 화면     │
│ (본인 기록만)    │   │ (본인 기록만)    │   │  (모든 기록)     │
│                 │   │                 │   │                 │
│ 🔄 상점이       │   │ 🎉 새로운 상점이 │   │ 🔄 상점이       │
│ 추가되었습니다   │   │ 부여되었습니다!  │   │ 추가되었습니다   │
│                 │   │                 │   │ (순위 갱신)      │
└─────────────────┘   └─────────────────┘   └─────────────────┘
```

---

### 🧪 과제 8: 관리자용 실시간 구독 코드 작성하기

`students` 테이블의 변경을 감지하는 관리자용 실시간 구독 코드를 작성해보세요.
(힌트: 관리자는 필터 없이 모든 변경을 감지합니다)

<details>
<summary>정답 보기</summary>

```typescript
useEffect(() => {
  const studentsChannel = supabase
    .channel('admin_students_changes')
    .on(
      'postgres_changes',
      { event: '*', schema: 'public', table: 'students' },  // 필터 없음
      (payload) => {
        console.log('Students changed:', payload);
        loadStudents();  // 학생 목록 새로고침
        
        if (payload.eventType === 'INSERT') {
          toast.info('🔄 새 학생이 추가되었습니다');
        } else if (payload.eventType === 'UPDATE') {
          toast.info('🔄 학생 정보가 수정되었습니다');
        } else if (payload.eventType === 'DELETE') {
          toast.info('🔄 학생이 삭제되었습니다');
        }
      }
    )
    .subscribe();

  return () => {
    supabase.removeChannel(studentsChannel);
  };
}, []);
```

</details>

---

### 💻 데이터 조회 (DataInquiry) 실시간 동기화 코드

데이터 조회 컴포넌트는 학생, 교사, 상점, 벌점, 이달의 학생 등 **다양한 데이터 유형**을 조회합니다.
따라서 **5개의 테이블**을 모두 구독해야 합니다!

#### Step 1: 페이지 포커스 시 새로고침

```typescript
// 페이지 포커스 시 데이터 새로고침
useEffect(() => {
  const handleVisibilityChange = () => {
    if (document.visibilityState === 'visible' && data.length > 0) {
      handleQuery();  // 현재 조회된 데이터가 있으면 새로고침
    }
  };

  const handleFocus = () => {
    if (data.length > 0) {
      handleQuery();
    }
  };

  document.addEventListener('visibilitychange', handleVisibilityChange);
  window.addEventListener('focus', handleFocus);

  return () => {
    document.removeEventListener('visibilitychange', handleVisibilityChange);
    window.removeEventListener('focus', handleFocus);
  };
}, [data.length, dataType, grade, classNum]);  // dataType도 의존성에 포함!
```

**쉽게 이해하기:**
- `dataType`: 현재 조회 중인 데이터 유형 (학생, 교사, 상점 등)
- 데이터 유형이 바뀌면 이벤트 리스너도 다시 설정됩니다

---

#### Step 2: 다섯 테이블 모두 실시간 구독

```typescript
// 실시간 동기화 - 모든 테이블 구독
useEffect(() => {
  // 학생(students) 채널
  const studentsChannel = supabase
    .channel('datainquiry_students_changes')
    .on(
      'postgres_changes',
      { event: '*', schema: 'public', table: 'students' },
      (payload) => {
        console.log('DataInquiry - Students changed:', payload);
        if (data.length > 0 && dataType === 'students') {
          handleQuery();  // 학생 조회 중일 때만 새로고침
        }
        if (payload.eventType === 'INSERT') {
          toast.info('🔄 학생이 추가되었습니다');
        } else if (payload.eventType === 'UPDATE') {
          toast.info('🔄 학생 정보가 수정되었습니다');
        } else if (payload.eventType === 'DELETE') {
          toast.info('🔄 학생이 삭제되었습니다');
        }
      }
    )
    .subscribe();

  // 교사(teachers) 채널
  const teachersChannel = supabase
    .channel('datainquiry_teachers_changes')
    .on(
      'postgres_changes',
      { event: '*', schema: 'public', table: 'teachers' },
      (payload) => {
        console.log('DataInquiry - Teachers changed:', payload);
        if (data.length > 0 && dataType === 'teachers') {
          handleQuery();  // 교사 조회 중일 때만 새로고침
        }
        if (payload.eventType === 'INSERT') {
          toast.info('🔄 교사가 추가되었습니다');
        } else if (payload.eventType === 'UPDATE') {
          toast.info('🔄 교사 정보가 수정되었습니다');
        } else if (payload.eventType === 'DELETE') {
          toast.info('🔄 교사가 삭제되었습니다');
        }
      }
    )
    .subscribe();

  // 상점(merits) 채널
  const meritsChannel = supabase
    .channel('datainquiry_merits_changes')
    .on(
      'postgres_changes',
      { event: '*', schema: 'public', table: 'merits' },
      (payload) => {
        console.log('DataInquiry - Merits changed:', payload);
        if (data.length > 0 && dataType === 'merits') {
          handleQuery();
        }
        if (payload.eventType === 'INSERT') {
          toast.info('🔄 상점이 추가되었습니다');
        } else if (payload.eventType === 'UPDATE') {
          toast.info('🔄 상점이 수정되었습니다');
        } else if (payload.eventType === 'DELETE') {
          toast.info('🔄 상점이 삭제되었습니다');
        }
      }
    )
    .subscribe();

  // 벌점(demerits) 채널
  const demeritsChannel = supabase
    .channel('datainquiry_demerits_changes')
    .on(
      'postgres_changes',
      { event: '*', schema: 'public', table: 'demerits' },
      (payload) => {
        console.log('DataInquiry - Demerits changed:', payload);
        if (data.length > 0 && dataType === 'demerits') {
          handleQuery();
        }
        if (payload.eventType === 'INSERT') {
          toast.info('🔄 벌점이 추가되었습니다');
        } else if (payload.eventType === 'UPDATE') {
          toast.info('🔄 벌점이 수정되었습니다');
        } else if (payload.eventType === 'DELETE') {
          toast.info('🔄 벌점이 삭제되었습니다');
        }
      }
    )
    .subscribe();

  // 이달의 학생(monthly) 채널
  const monthlyChannel = supabase
    .channel('datainquiry_monthly_changes')
    .on(
      'postgres_changes',
      { event: '*', schema: 'public', table: 'monthly' },
      (payload) => {
        console.log('DataInquiry - Monthly changed:', payload);
        if (data.length > 0 && dataType === 'monthly') {
          handleQuery();
        }
        if (payload.eventType === 'INSERT') {
          toast.info('🔄 이달의 학생이 추가되었습니다');
        } else if (payload.eventType === 'UPDATE') {
          toast.info('🔄 이달의 학생이 수정되었습니다');
        } else if (payload.eventType === 'DELETE') {
          toast.info('🔄 이달의 학생이 삭제되었습니다');
        }
      }
    )
    .subscribe();

  // Cleanup: 모든 채널 제거
  return () => {
    supabase.removeChannel(studentsChannel);
    supabase.removeChannel(teachersChannel);
    supabase.removeChannel(meritsChannel);
    supabase.removeChannel(demeritsChannel);
    supabase.removeChannel(monthlyChannel);
  };
}, [data.length, dataType, grade, classNum]);
```

**쉽게 이해하기:**
- 5개의 채널을 만들어서 5개의 테이블 변경을 모두 감지합니다
- `dataType === 'students'` 같은 조건으로 현재 보고 있는 데이터 유형일 때만 새로고침합니다
- 토스트 알림은 어떤 데이터를 보고 있든 항상 표시됩니다 (다른 탭의 변경도 알 수 있음)

---

### 🤔 왜 조건부로 새로고침할까요?

```typescript
// 방법 1: 무조건 새로고침 (비효율적!)
if (data.length > 0) {
  handleQuery();  // 상점 조회 중인데 교사 변경 시에도 새로고침 😓
}

// 방법 2: 조건부 새로고침 (효율적!)
if (data.length > 0 && dataType === 'students') {
  handleQuery();  // 학생 조회 중일 때만 새로고침 😊
}
```

**DataInquiry**는 여러 종류의 데이터를 조회하므로:
- 학생 목록을 보고 있는데 교사 데이터가 바뀌어도 새로고침할 필요 없습니다
- 현재 보고 있는 `dataType`과 같은 테이블이 변경되었을 때만 새로고침합니다

---

### 🧪 과제 9: 조건부 새로고침 코드 작성하기

이메일 히스토리 테이블 변경 시, 현재 `dataType`이 'email_history'일 때만 새로고침하는 코드를 작성해보세요.

<details>
<summary>정답 보기</summary>

```typescript
const emailHistoryChannel = supabase
  .channel('datainquiry_email_history_changes')
  .on(
    'postgres_changes',
    { event: '*', schema: 'public', table: 'email_history' },
    (payload) => {
      console.log('DataInquiry - Email history changed:', payload);
      
      // 조건부 새로고침: 이메일 히스토리 조회 중일 때만
      if (data.length > 0 && dataType === 'email_history') {
        handleQuery();
      }
      
      if (payload.eventType === 'INSERT') {
        toast.info('🔄 이메일이 발송되었습니다');
      } else if (payload.eventType === 'UPDATE') {
        toast.info('🔄 이메일 정보가 수정되었습니다');
      } else if (payload.eventType === 'DELETE') {
        toast.info('🔄 이메일이 삭제되었습니다');
      }
    }
  )
  .subscribe();
```

</details>

---

## 📌 오늘 배운 핵심 개념

| 개념 | 설명 | 예시 |
|------|------|------|
| 상태(State) | 화면에 보여지는 데이터를 저장 | `useState()` |
| 편집 모드 | 수정 중임을 표시하는 상태 | `editingMembersGroupId` |
| Supabase update | 데이터베이스 수정 | `.update({ 컬럼: 값 })` |
| map() | 배열의 각 항목을 변환 | `array.map(item => ...)` |
| 스프레드 연산자 | 객체/배열 복사 | `{ ...object }` |
| 조건부 렌더링 | 조건에 따라 화면 표시 | `{조건 && <컴포넌트/>}` |
| **Realtime** | 실시간 데이터 동기화 | `supabase.channel().on()` |
| **이벤트 리스너** | 특정 이벤트 감지 | `addEventListener()` |
| **Cleanup 함수** | 컴포넌트 정리 작업 | `return () => { ... }` |
| **payload.eventType** | 변경 유형 (INSERT/UPDATE/DELETE) | `if (payload.eventType === 'INSERT')` |
| **토스트 알림** | 사용자에게 알림 표시 | `toast.success()`, `toast.info()` |
| **필터 옵션** | 특정 조건의 데이터만 구독 | `filter: \`teacher_id=eq.${id}\`` |
| **조건부 새로고침** | 현재 보는 데이터 유형일 때만 갱신 | `if (dataType === 'students')` |

---

## 🔗 다음 단계
- 그룹 복사 기능 만들어보기
- 그룹 내 학생 순서 변경 기능 추가하기
- 여러 그룹 한 번에 선택해서 발송하기
- 실시간 알림에 학생 이름이나 점수 정보 추가하기
- 실시간 동기화 코드를 재사용 가능한 커스텀 훅으로 리팩토링하기
