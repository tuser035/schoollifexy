# 🔧 커스텀 훅으로 코드 리팩토링하기

**작성일**: 2025년 12월 15일 (오전 11:44경)  
**대상**: 중학생도 따라할 수 있는 수준  
**목표**: 반복되는 코드를 한 곳에 모아서 깔끔하게 정리하기

---

## 📚 목차

1. [리팩토링이 뭐예요?](#1-리팩토링이-뭐예요)
2. [문제 상황 이해하기](#2-문제-상황-이해하기)
3. [커스텀 훅이란?](#3-커스텀-훅이란)
4. [커스텀 훅 만들기](#4-커스텀-훅-만들기)
5. [컴포넌트에서 사용하기](#5-컴포넌트에서-사용하기)
6. [실제 적용 예시](#6-실제-적용-예시)
7. [연습 문제](#7-연습-문제)

---

## 1. 리팩토링이 뭐예요?

### 🤔 리팩토링의 정의

**리팩토링(Refactoring)** = 코드가 하는 일은 똑같지만, 코드를 더 깔끔하게 정리하는 것

비유로 설명하면:
- 🏠 **방 정리**: 물건들은 그대로지만, 정리하면 찾기 쉬워짐
- 📚 **필기 정리**: 같은 내용이지만, 깔끔하게 정리하면 공부하기 편함

### 🎯 왜 리팩토링을 할까요?

| 리팩토링 전 | 리팩토링 후 |
|------------|-----------|
| 같은 코드가 여러 곳에 반복 | 한 곳에만 있음 |
| 수정할 때 여러 파일 수정 | 한 파일만 수정 |
| 버그 발생 확률 높음 | 버그 발생 확률 낮음 |
| 코드 이해하기 어려움 | 코드 이해하기 쉬움 |

---

## 2. 문제 상황 이해하기

### 😰 반복되는 코드 발견!

실시간 동기화 기능을 만들 때, 이런 코드가 **여러 컴포넌트에 반복**되었습니다:

```typescript
// PointsInquiry.tsx에도 있고...
useEffect(() => {
  const handleVisibilityChange = () => {
    if (document.visibilityState === 'visible') {
      loadData();  // 페이지 보일 때 새로고침
    }
  };
  document.addEventListener('visibilitychange', handleVisibilityChange);
  window.addEventListener('focus', handleFocus);
  
  return () => {
    document.removeEventListener('visibilitychange', handleVisibilityChange);
    window.removeEventListener('focus', handleFocus);
  };
}, []);

useEffect(() => {
  const channel = supabase
    .channel('some_channel')
    .on('postgres_changes', { event: '*', schema: 'public', table: 'merits' }, 
      (payload) => {
        loadData();
        toast.info('데이터가 변경되었습니다');
      }
    )
    .subscribe();
  
  return () => supabase.removeChannel(channel);
}, []);
```

```typescript
// CounselingInquiry.tsx에도 있고...
useEffect(() => {
  const handleVisibilityChange = () => {
    if (document.visibilityState === 'visible') {
      loadCounseling();  // 거의 똑같은 코드!
    }
  };
  // ... 나머지도 거의 똑같음
}, []);
```

```typescript
// StudentGroupManager.tsx에도 있고...
// ... 또 비슷한 코드!
```

### 📊 문제점 분석

```
┌─────────────────────────────────────────────────────────────┐
│  여러 컴포넌트에 같은 코드가 반복됨                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  PointsInquiry.tsx      CounselingInquiry.tsx              │
│  ┌─────────────────┐    ┌─────────────────┐                │
│  │ 페이지 포커스    │    │ 페이지 포커스    │                │
│  │ 이벤트 리스너    │    │ 이벤트 리스너    │  ← 같은 코드!   │
│  │ 실시간 구독     │    │ 실시간 구독     │                │
│  │ 토스트 알림     │    │ 토스트 알림     │                │
│  │ Cleanup        │    │ Cleanup        │                │
│  └─────────────────┘    └─────────────────┘                │
│                                                             │
│  StudentGroupManager.tsx    EmailHistory.tsx               │
│  ┌─────────────────┐        ┌─────────────────┐            │
│  │ 또 같은 코드!    │        │ 또 같은 코드!    │            │
│  └─────────────────┘        └─────────────────┘            │
│                                                             │
│  문제: 수정이 필요하면 4개 파일 모두 수정해야 함!            │
└─────────────────────────────────────────────────────────────┘
```

---

## 3. 커스텀 훅이란?

### 🪝 훅(Hook) 복습

React에서 훅은 특별한 기능을 가진 함수입니다:

| 훅 이름 | 하는 일 | 예시 |
|--------|--------|------|
| `useState` | 상태 저장 | `const [count, setCount] = useState(0)` |
| `useEffect` | 부수 효과 실행 | `useEffect(() => { ... }, [])` |
| `useCallback` | 함수 기억하기 | `useCallback(() => { ... }, [deps])` |
| `useRef` | 값 참조하기 | `const ref = useRef(null)` |

### 🎨 커스텀 훅 = 나만의 훅

**커스텀 훅**은 위의 기본 훅들을 조합해서 만든 **나만의 훅**입니다.

```
기본 훅들                    커스텀 훅
┌─────────────┐           ┌─────────────────────┐
│ useState    │──────┐    │ useRealtimeSync     │
│ useEffect   │──────┼───▶│                     │
│ useCallback │──────┤    │ (여러 기능 통합!)    │
│ useRef      │──────┘    └─────────────────────┘
└─────────────┘
```

### 📏 커스텀 훅의 규칙

1. **이름은 `use`로 시작해야 함**: `useRealtimeSync`, `useAuth`, `useUser` 등
2. **다른 훅을 사용할 수 있음**: 안에서 `useState`, `useEffect` 등 사용 가능
3. **재사용 가능**: 여러 컴포넌트에서 같은 훅 사용 가능

---

## 4. 커스텀 훅 만들기

### 📁 파일 생성

`src/hooks/use-realtime-sync.ts` 파일을 만듭니다.

### 💻 전체 코드

```typescript
// src/hooks/use-realtime-sync.ts

import { useEffect, useCallback, useRef } from "react";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";

// ============================================================
// 1단계: 타입 정의하기
// ============================================================

// 테이블 구독 설정을 위한 타입
export interface TableSubscription {
  table: string;           // 구독할 테이블 이름 (예: 'merits', 'students')
  channelName: string;     // 채널 고유 이름 (중복되면 안 됨!)
  filter?: string;         // 필터 조건 (선택사항)
  labels?: {               // 토스트 메시지 (선택사항)
    insert?: string;       // 데이터 추가 시 메시지
    update?: string;       // 데이터 수정 시 메시지
    delete?: string;       // 데이터 삭제 시 메시지
  };
  condition?: () => boolean;  // 새로고침 조건 (선택사항)
}

// 훅 옵션 타입
export interface UseRealtimeSyncOptions {
  tables: TableSubscription[];  // 구독할 테이블 목록
  onRefresh: () => void;        // 데이터 새로고침 함수
  enabled?: boolean;            // 활성화 여부 (기본값: true)
  dependencies?: any[];         // 의존성 배열
}
```

**코드 설명 (타입 정의):**

```
TableSubscription = 테이블 하나를 구독하기 위한 설정
├── table: 어떤 테이블? (예: "merits")
├── channelName: 채널 이름 (고유해야 함!)
├── filter: 조건 (예: "teacher_id=eq.abc123")
├── labels: 알림 메시지
│   ├── insert: 추가될 때
│   ├── update: 수정될 때
│   └── delete: 삭제될 때
└── condition: 언제 새로고침할지 조건
```

### 💻 훅 본체 코드

```typescript
// ============================================================
// 2단계: 커스텀 훅 만들기
// ============================================================

export const useRealtimeSync = ({
  tables,
  onRefresh,
  enabled = true,
  dependencies = [],
}: UseRealtimeSyncOptions) => {
  
  // onRefresh 함수의 최신 버전을 저장하는 ref
  // 왜? useEffect 안에서 항상 최신 함수를 사용하려고!
  const onRefreshRef = useRef(onRefresh);
  
  // onRefresh가 바뀌면 ref도 업데이트
  useEffect(() => {
    onRefreshRef.current = onRefresh;
  }, [onRefresh]);

  // --------------------------------------------------------
  // 기능 1: 페이지 포커스 시 새로고침
  // --------------------------------------------------------
  useEffect(() => {
    if (!enabled) return;  // 비활성화면 아무것도 안 함

    // 페이지가 보일 때 (다른 탭에서 돌아올 때)
    const handleVisibilityChange = () => {
      if (document.visibilityState === 'visible') {
        onRefreshRef.current();
      }
    };

    // 창이 포커스될 때
    const handleFocus = () => {
      onRefreshRef.current();
    };

    // 이벤트 등록
    document.addEventListener('visibilitychange', handleVisibilityChange);
    window.addEventListener('focus', handleFocus);

    // Cleanup: 컴포넌트가 사라질 때 이벤트 제거
    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      window.removeEventListener('focus', handleFocus);
    };
  }, [enabled, ...dependencies]);

  // --------------------------------------------------------
  // 기능 2: 실시간 테이블 구독
  // --------------------------------------------------------
  useEffect(() => {
    const channels: any[] = [];  // 생성된 채널들을 저장

    // 각 테이블에 대해 채널 생성
    tables.forEach(({ table, channelName, filter, labels, condition }) => {
      
      // 채널 설정 객체
      const channelConfig: any = { 
        event: '*',       // 모든 이벤트 (INSERT, UPDATE, DELETE)
        schema: 'public', // public 스키마
        table             // 테이블 이름
      };
      
      // 필터가 있으면 추가
      if (filter) {
        channelConfig.filter = filter;
      }

      // 채널 생성 및 구독
      const channel = supabase
        .channel(channelName)
        .on('postgres_changes', channelConfig, (payload) => {
          console.log(`Realtime - ${table} changed:`, payload);
          
          // 조건이 있고, 조건이 false면 무시
          if (condition && !condition()) {
            return;
          }
          
          // 새로고침 실행
          if (enabled) {
            onRefreshRef.current();
          }
          
          // 토스트 알림 표시
          if (payload.eventType === 'INSERT' && labels?.insert) {
            toast.info(labels.insert);
          } else if (payload.eventType === 'UPDATE' && labels?.update) {
            toast.info(labels.update);
          } else if (payload.eventType === 'DELETE' && labels?.delete) {
            toast.info(labels.delete);
          }
        })
        .subscribe();

      channels.push(channel);  // 채널 저장
    });

    // Cleanup: 모든 채널 제거
    return () => {
      channels.forEach(channel => {
        supabase.removeChannel(channel);
      });
    };
  }, [enabled, ...dependencies]);
};
```

**코드 흐름 설명:**

```
useRealtimeSync 훅 호출됨
          │
          ▼
┌─────────────────────────────────────┐
│ 1. onRefreshRef 설정                │
│    (항상 최신 함수 참조)              │
└─────────────────────────────────────┘
          │
          ▼
┌─────────────────────────────────────┐
│ 2. 페이지 포커스 이벤트 등록          │
│    - visibilitychange               │
│    - focus                          │
└─────────────────────────────────────┘
          │
          ▼
┌─────────────────────────────────────┐
│ 3. Supabase 채널 구독               │
│    - 각 테이블마다 채널 생성          │
│    - 변경 감지하면 onRefresh 호출     │
│    - 토스트 알림 표시                │
└─────────────────────────────────────┘
          │
          ▼
┌─────────────────────────────────────┐
│ 4. Cleanup 함수                     │
│    - 이벤트 리스너 제거              │
│    - 채널 구독 해제                  │
└─────────────────────────────────────┘
```

### 💻 미리 정의된 테이블 설정

자주 사용하는 테이블은 미리 정의해둡니다:

```typescript
// ============================================================
// 3단계: 자주 쓰는 테이블 설정 미리 정의
// ============================================================

// 상벌점 테이블들
export const POINTS_TABLES: TableSubscription[] = [
  {
    table: 'merits',
    channelName: 'realtime_merits',
    labels: {
      insert: '🔄 상점이 추가되었습니다',
      update: '🔄 상점이 수정되었습니다',
      delete: '🔄 상점이 삭제되었습니다',
    },
  },
  {
    table: 'demerits',
    channelName: 'realtime_demerits',
    labels: {
      insert: '🔄 벌점이 추가되었습니다',
      update: '🔄 벌점이 수정되었습니다',
      delete: '🔄 벌점이 삭제되었습니다',
    },
  },
  {
    table: 'monthly',
    channelName: 'realtime_monthly',
    labels: {
      insert: '🔄 이달의 학생이 추가되었습니다',
      update: '🔄 이달의 학생이 수정되었습니다',
      delete: '🔄 이달의 학생이 삭제되었습니다',
    },
  },
];

// 상담 테이블
export const COUNSELING_TABLE: TableSubscription[] = [
  {
    table: 'career_counseling',
    channelName: 'realtime_counseling',
    labels: {
      insert: '🔄 상담 기록이 추가되었습니다',
      update: '🔄 상담 기록이 수정되었습니다',
      delete: '🔄 상담 기록이 삭제되었습니다',
    },
  },
];

// 이메일 히스토리 테이블
export const EMAIL_HISTORY_TABLE: TableSubscription[] = [
  {
    table: 'email_history',
    channelName: 'realtime_email_history',
    labels: {
      insert: '🔄 이메일이 발송되었습니다',
      update: '🔄 이메일 정보가 수정되었습니다',
      delete: undefined,  // 삭제 알림은 안 보냄
    },
  },
];
```

---

## 5. 컴포넌트에서 사용하기

### 📝 기본 사용법

```typescript
import { useRealtimeSync, POINTS_TABLES } from "@/hooks/use-realtime-sync";
import { useCallback } from "react";

const MyComponent = () => {
  const [data, setData] = useState([]);
  
  // 1. 새로고침 함수를 useCallback으로 감싸기
  const handleRefresh = useCallback(() => {
    loadData();  // 데이터 다시 불러오는 함수
  }, []);

  // 2. 커스텀 훅 호출
  useRealtimeSync({
    tables: POINTS_TABLES,
    onRefresh: handleRefresh,
    enabled: data.length > 0,  // 데이터가 있을 때만 활성화
  });

  // ... 나머지 코드
};
```

### 🔑 핵심 포인트

1. **useCallback 사용**: 새로고침 함수를 `useCallback`으로 감싸야 불필요한 재구독 방지
2. **enabled 조건**: 데이터가 있을 때만 활성화하면 효율적
3. **채널 이름 중복 주의**: 같은 테이블이라도 채널 이름은 달라야 함

---

## 6. 실제 적용 예시

### 예시 1: StudentGroupManager

**변경 전 (60줄 이상):**

```typescript
// 페이지 포커스 시 새로고침 (20줄)
useEffect(() => {
  const handleVisibilityChange = () => { ... };
  const handleFocus = () => { ... };
  document.addEventListener('visibilitychange', handleVisibilityChange);
  window.addEventListener('focus', handleFocus);
  return () => { ... };
}, []);

// 실시간 구독 (25줄)
useEffect(() => {
  const channel = supabase
    .channel('student_groups_changes')
    .on('postgres_changes', { ... }, (payload) => {
      loadGroups();
      if (payload.eventType === 'INSERT') toast.info('...');
      // ...
    })
    .subscribe();
  return () => supabase.removeChannel(channel);
}, []);
```

**변경 후 (15줄):**

```typescript
import { useRealtimeSync, TableSubscription } from "@/hooks/use-realtime-sync";

// 테이블 설정
const groupTables: TableSubscription[] = user ? [
  {
    channelName: "student-group-manager",
    table: "student_groups",
    filter: `admin_id=eq.${user.id}`,
    labels: {
      insert: "🔄 새 그룹이 추가되었습니다",
      update: "🔄 그룹이 수정되었습니다",
      delete: "🔄 그룹이 삭제되었습니다",
    },
  },
] : [];

// 새로고침 함수
const handleRefresh = useCallback(() => {
  loadGroups();
}, []);

// 커스텀 훅 호출 - 끝!
useRealtimeSync({
  tables: groupTables,
  onRefresh: handleRefresh,
  enabled: !!user,
});
```

### 예시 2: BulkEmailSender

```typescript
// 그룹과 템플릿 모두 실시간 감지
const bulkEmailTables: TableSubscription[] = user ? [
  {
    channelName: "bulk-email-student-groups",
    table: "student_groups",
    filter: `admin_id=eq.${user.id}`,
    labels: {
      insert: "🔄 학생 그룹이 추가되었습니다",
      update: "🔄 학생 그룹이 수정되었습니다",
      delete: "🔄 학생 그룹이 삭제되었습니다",
    },
  },
  {
    channelName: "bulk-email-templates",
    table: "email_templates",
    labels: {
      insert: "🔄 이메일 템플릿이 추가되었습니다",
      update: "🔄 이메일 템플릿이 수정되었습니다",
      delete: "🔄 이메일 템플릿이 삭제되었습니다",
    },
  },
] : [];

const handleRefresh = useCallback(() => {
  loadGroups();
  loadTemplates();
}, []);

useRealtimeSync({
  tables: bulkEmailTables,
  onRefresh: handleRefresh,
  enabled: !!user,
});
```

### 📊 리팩토링 결과 비교

| 항목 | 리팩토링 전 | 리팩토링 후 |
|------|------------|------------|
| 코드 줄 수 | ~60-100줄 | ~15-20줄 |
| 중복 코드 | 모든 컴포넌트에 반복 | 훅에 한 번만 |
| 유지보수 | 수정 시 여러 파일 | 훅만 수정 |
| 버그 위험 | 높음 (각각 다르게 구현 가능) | 낮음 (통일된 구현) |
| 가독성 | 낮음 | 높음 |

---

## 7. 연습 문제

### 🧪 문제 1: 기본 개념 확인

다음 중 커스텀 훅에 대한 설명으로 **올바른 것**을 모두 고르세요.

1. 커스텀 훅 이름은 반드시 `use`로 시작해야 한다
2. 커스텀 훅 안에서 `useState`를 사용할 수 없다
3. 커스텀 훅은 여러 컴포넌트에서 재사용할 수 있다
4. 커스텀 훅은 일반 함수와 완전히 같다

<details>
<summary>정답 보기</summary>

**정답: 1, 3**

- ✅ 1번: 맞음. React 규칙!
- ❌ 2번: 틀림. 사용할 수 있음!
- ✅ 3번: 맞음. 재사용이 핵심 장점!
- ❌ 4번: 틀림. 훅은 다른 훅을 사용할 수 있는 특별한 함수!

</details>

---

### 🧪 문제 2: 채널 이름

아래 코드에서 **문제점**을 찾아보세요.

```typescript
// ComponentA.tsx
useRealtimeSync({
  tables: [{
    channelName: "merits_channel",  // ⚠️
    table: "merits",
    // ...
  }],
  // ...
});

// ComponentB.tsx
useRealtimeSync({
  tables: [{
    channelName: "merits_channel",  // ⚠️ 같은 이름!
    table: "merits",
    // ...
  }],
  // ...
});
```

<details>
<summary>정답 보기</summary>

**문제점: 채널 이름이 중복됨!**

채널 이름이 같으면 충돌이 발생합니다. 각 컴포넌트마다 고유한 이름을 사용해야 합니다.

**수정된 코드:**
```typescript
// ComponentA.tsx
channelName: "component_a_merits"

// ComponentB.tsx
channelName: "component_b_merits"
```

</details>

---

### 🧪 문제 3: 직접 만들어보기

`audit_logs` 테이블의 변경을 감지하는 실시간 동기화 코드를 작성해보세요.

요구사항:
- 테이블: `audit_logs`
- 채널 이름: `audit_logs_viewer`
- INSERT 시 메시지: `"🔄 새로운 로그가 기록되었습니다"`
- UPDATE/DELETE 알림은 필요 없음

<details>
<summary>정답 보기</summary>

```typescript
import { useRealtimeSync, TableSubscription } from "@/hooks/use-realtime-sync";
import { useCallback, useState } from "react";

const AuditLogViewer = () => {
  const [logs, setLogs] = useState([]);
  
  const loadLogs = async () => {
    // 로그 불러오는 로직
  };

  const handleRefresh = useCallback(() => {
    loadLogs();
  }, []);

  const auditLogTables: TableSubscription[] = [
    {
      table: 'audit_logs',
      channelName: 'audit_logs_viewer',
      labels: {
        insert: '🔄 새로운 로그가 기록되었습니다',
        // update, delete는 undefined (알림 안 보냄)
      },
    },
  ];

  useRealtimeSync({
    tables: auditLogTables,
    onRefresh: handleRefresh,
    enabled: true,
  });

  return (
    <div>
      {/* 로그 목록 표시 */}
    </div>
  );
};
```

</details>

---

### 🧪 문제 4: 조건부 새로고침

학생 테이블과 교사 테이블을 둘 다 구독하지만, **현재 선택된 탭에 해당하는 테이블이 변경될 때만** 새로고침하는 코드를 작성해보세요.

<details>
<summary>힌트</summary>

`condition` 속성을 사용하세요!

```typescript
condition: () => selectedTab === 'students'
```

</details>

<details>
<summary>정답 보기</summary>

```typescript
const [selectedTab, setSelectedTab] = useState('students');
const [data, setData] = useState([]);

const handleRefresh = useCallback(() => {
  loadData(selectedTab);
}, [selectedTab]);

const tables: TableSubscription[] = [
  {
    table: 'students',
    channelName: 'data_inquiry_students',
    labels: { insert: '🔄 학생이 추가되었습니다', ... },
    condition: () => selectedTab === 'students' && data.length > 0,
  },
  {
    table: 'teachers',
    channelName: 'data_inquiry_teachers',
    labels: { insert: '🔄 교사가 추가되었습니다', ... },
    condition: () => selectedTab === 'teachers' && data.length > 0,
  },
];

useRealtimeSync({
  tables,
  onRefresh: handleRefresh,
  enabled: data.length > 0,
  dependencies: [selectedTab, data.length],
});
```

**핵심 포인트:**
- `condition`으로 현재 탭과 일치할 때만 새로고침
- `dependencies`에 `selectedTab` 추가하여 탭 변경 시 재구독

</details>

---

## 📌 핵심 정리

| 개념 | 설명 | 예시 |
|------|------|------|
| **리팩토링** | 기능은 같고 코드만 정리 | 반복 코드 → 함수로 추출 |
| **커스텀 훅** | 재사용 가능한 로직 묶음 | `useRealtimeSync()` |
| **useRef** | 렌더링 사이에 값 유지 | `useRef(onRefresh)` |
| **useCallback** | 함수 메모이제이션 | `useCallback(() => {}, [])` |
| **채널 이름** | 구독 식별자 (고유해야 함) | `"component_name_table"` |
| **condition** | 조건부 새로고침 | `() => tab === 'students'` |
| **Cleanup** | 컴포넌트 정리 작업 | `return () => { ... }` |

---

## 🎉 마무리

오늘 배운 내용:

1. ✅ **리팩토링**의 개념과 필요성
2. ✅ **커스텀 훅** 만드는 방법
3. ✅ **useRealtimeSync** 훅의 구조와 동작 원리
4. ✅ 컴포넌트에서 **실제 사용하는 방법**
5. ✅ 코드 **60줄 → 15줄**로 줄이는 마법!

리팩토링은 처음엔 시간이 걸리지만, 나중에 유지보수할 때 **훨씬 편해집니다**! 
반복되는 코드를 발견하면 "이거 커스텀 훅으로 만들 수 있지 않을까?" 생각해보세요. 🚀
