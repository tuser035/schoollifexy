# 커스텀 인증과 보안 이해하기

> 작성일: 2025-12-15  
> 대상: 중학생 수준의 초보 개발자  
> 주제: Supabase에서 커스텀 인증 방식의 보안 원리

---

## 📚 학습 목표

이 문서를 읽고 나면 다음을 이해할 수 있어요:
1. Supabase Auth와 커스텀 인증의 차이점
2. RLS(Row Level Security)가 어떻게 데이터를 보호하는지
3. 커스텀 인증이 안전한 이유
4. Storage 업로드에서 anon 역할이 필요한 이유

---

## 1. 두 가지 인증 방식 비교

### Supabase Auth (표준 방식)

```
👤 사용자 → 🔑 로그인 → 🎫 JWT 토큰 발급
                             ↓
                   데이터베이스가 토큰으로
                   "이 사람 누구인지" 자동 확인
                             ↓
                   auth.uid() = 사용자 ID
```

**특징:**
- Supabase가 제공하는 내장 인증 시스템
- 로그인하면 JWT 토큰이 발급됨
- 토큰에 사용자 정보가 포함되어 있음
- RLS 정책에서 `auth.uid()`로 현재 사용자 확인 가능

### 커스텀 Auth (우리 앱 방식)

```
👤 사용자 → 🚪 RPC 함수 호출 → 함수가 비밀번호 확인
                                   ↓
                         세션 변수 설정
                   (app.current_teacher_id)
                                   ↓
                   RLS가 세션 변수로 확인
```

**특징:**
- 우리가 직접 만든 인증 시스템
- RPC 함수가 비밀번호를 확인
- 세션 변수에 사용자 ID 저장
- RLS 정책에서 세션 변수로 현재 사용자 확인

---

## 2. Supabase의 역할(Role) 시스템

Supabase에는 여러 가지 "역할"이 있어요. 학교에 비유하면 이해하기 쉬워요!

| 역할 | 학교 비유 | 설명 |
|------|----------|------|
| `anon` | 학교 앞 행인 | 학생증 없음, 정문까지만 접근 가능 |
| `authenticated` | 학생증 있는 학생 | 교실, 도서관 등 접근 가능 |
| `service_role` | 교장 선생님 | 모든 곳 접근 가능 (관리자용) |

### 중요한 포인트!

우리 앱은 Supabase Auth를 사용하지 않기 때문에, 모든 요청이 `anon` 역할로 들어와요.
하지만 이것이 보안 문제가 되지 않는 이유가 있어요!

---

## 3. 우리 앱이 안전한 이유

### 해커가 공격을 시도한다면?

```
해커의 시도: 직접 테이블 접근
supabase.from('students').select('*')
              │
              ▼
     ┌─────────────────┐
     │   RLS 정책 검사  │
     │                 │
     │  세션 변수가    │
     │  설정됐나요?    │
     └─────────────────┘
          │        │
         없음      있음
          │        │
          ▼        ▼
     ❌ 차단!   ✅ 허용
     (권한 없음)
```

### 보안이 유지되는 핵심 원리

1. **RLS가 모든 직접 접근을 차단**
   - `anon` 역할은 테이블에 직접 접근할 수 없음
   - 세션 변수가 없으면 RLS가 거부

2. **RPC 함수가 유일한 입구**
   - 모든 데이터 접근은 RPC 함수를 통해서만 가능
   - RPC 함수는 `SECURITY DEFINER`로 실행됨

3. **함수 내부에서 권한 검증**
   - RPC 함수가 사용자의 권한을 직접 확인
   - 가짜 ID로 호출해도 함수가 거부

---

## 4. SECURITY DEFINER 이해하기

### 일반 함수 vs SECURITY DEFINER 함수

```sql
-- 일반 함수: 호출한 사람의 권한으로 실행
CREATE FUNCTION get_data()
RETURNS TABLE(...) AS $$
  SELECT * FROM students;  -- anon 권한으로 실행 → 실패!
$$ LANGUAGE sql;

-- SECURITY DEFINER: 함수 만든 사람의 권한으로 실행
CREATE FUNCTION get_data()
RETURNS TABLE(...)
SECURITY DEFINER  -- ⭐ 이게 핵심!
AS $$
  SELECT * FROM students;  -- 관리자 권한으로 실행 → 성공!
$$ LANGUAGE sql;
```

### 비유로 이해하기

```
일반 함수:        학생이 도서관에 가서 책을 빌림
                 → 학생 권한으로만 가능한 책만 빌릴 수 있음

SECURITY DEFINER: 학생이 사서에게 책을 요청함
                 → 사서가 대신 책을 가져다줌
                 → 사서는 모든 책에 접근 가능
```

---

## 5. 보안 체크리스트

우리 앱에서 각 공격 시나리오가 어떻게 방어되는지 확인해보세요:

| 공격 시나리오 | 우리 앱 대응 | 안전 여부 |
|-------------|------------|----------|
| anon key로 직접 테이블 접근 | RLS가 차단 | ✅ |
| 가짜 teacher_id로 RPC 호출 | 함수 내부에서 권한 검증 | ✅ |
| localStorage 조작 | 서버(RPC)에서 재검증 | ✅ |
| 비밀번호 추측 | bcrypt 해시 + 느린 검증 | ✅ |

---

## 6. Storage는 왜 다른가요?

### 문제 상황

파일 업로드는 RPC 함수로 처리하기 어려워요. 왜냐하면:
- 파일 데이터를 RPC 함수에 전달하려면 Base64 인코딩이 필요
- 큰 파일은 이 방식으로 처리하기 어려움
- Supabase Storage API를 직접 사용해야 함

### 해결 방법

Storage에만 `anon` 역할의 업로드를 허용하는 RLS 정책을 만들어요:

```sql
-- anon과 authenticated 역할 모두에게 허용
CREATE POLICY "Public upload to email-attachments"
ON storage.objects FOR INSERT
TO anon, authenticated  -- 행인과 학생 모두 허용!
WITH CHECK (bucket_id = 'email-attachments');
```

### 이게 안전한 이유

1. **특정 버킷에만 허용**: `email-attachments` 버킷에만 업로드 가능
2. **다른 데이터는 안전**: 학생, 교사 정보 등은 여전히 RPC로만 접근 가능
3. **파일만 업로드 가능**: 테이블 데이터는 건드릴 수 없음

---

## 7. 코드 예시

### ❌ 위험한 코드 (직접 테이블 접근)

```typescript
// 이 코드는 RLS가 차단해야 함!
const { data } = await supabase
  .from('students')
  .select('*');

// 결과: 권한 없음 에러
```

### ✅ 안전한 코드 (RPC 함수 사용)

```typescript
// 이 코드는 안전함!
const { data } = await supabase
  .rpc('admin_get_students', { 
    admin_id_input: userId  // 함수 내부에서 권한 검증
  });

// 결과: 권한이 있으면 데이터 반환, 없으면 에러
```

---

## 8. 연습 문제

### 문제 1
다음 중 `anon` 역할에 대한 설명으로 올바른 것은?
- A) 관리자 권한을 가진 역할
- B) 로그인하지 않은 사용자의 역할
- C) 모든 테이블에 접근할 수 있는 역할

<details>
<summary>정답 보기</summary>
B) 로그인하지 않은 사용자의 역할
</details>

### 문제 2
SECURITY DEFINER 함수가 안전한 이유는?
- A) 아무나 호출할 수 있어서
- B) 함수 내부에서 권한을 검증하기 때문에
- C) 데이터를 암호화해서

<details>
<summary>정답 보기</summary>
B) 함수 내부에서 권한을 검증하기 때문에
</details>

### 문제 3
우리 앱에서 파일 업로드에 `anon` 역할을 허용하는 이유는?
- A) 보안이 필요 없어서
- B) 파일 업로드는 RPC로 처리하기 어려워서
- C) Supabase가 요구해서

<details>
<summary>정답 보기</summary>
B) 파일 업로드는 RPC로 처리하기 어려워서
</details>

---

## 9. 핵심 정리

1. **커스텀 인증도 안전해요!** 단, RLS + RPC 함수 조합이 필수
2. **RLS는 문지기**: 모든 직접 접근을 차단
3. **RPC는 유일한 입구**: 권한 검증 후에만 데이터 제공
4. **SECURITY DEFINER**: 함수가 높은 권한으로 실행되지만, 내부에서 검증
5. **Storage는 예외**: 파일 업로드만 anon 허용, 나머지는 여전히 보호

---

## 📖 더 알아보기

- [Supabase Row Level Security 공식 문서](https://supabase.com/docs/guides/auth/row-level-security)
- [PostgreSQL Security Definer 설명](https://www.postgresql.org/docs/current/sql-createfunction.html)
- [Supabase Storage 정책](https://supabase.com/docs/guides/storage/security/access-control)
